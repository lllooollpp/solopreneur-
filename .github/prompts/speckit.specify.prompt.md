---
description: 根据自然语言描述生成 feature 规范。
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

请务必在分析前充分考虑用户输入（如有）。

## 执行步骤

用户在触发消息中于 `/speckit.specify` 后输入的文本**即为**功能描述。假设在此对话中始终可用，即使下方字面显示 `{ARGS}`。除非用户提供空命令，否则不要要求用户重复。

根据该功能描述，执行以下操作：

1. **为分支生成简洁的短名称**（2-4 个词）：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个 2-4 个词的短名称，能够捕捉功能的本质
   - 尽可能使用动作-名词格式（例如，"add-user-auth"、"fix-payment-bug"）
   - 保留技术术语和缩写（OAuth2、API、JWT 等）
   - 保持简洁但足够描述以一目了然地理解功能
   - 示例：
     - "我想添加用户认证" → "user-auth"
     - "为 API 实现 OAuth2 集成" → "oauth2-api-integration"
     - "创建分析仪表板" → "analytics-dashboard"
     - "修复支付处理超时错误" → "fix-payment-timeout"

2. **在创建新分支前检查现有分支**：
   
   a. 首先，获取所有远程分支以确保我们有最新信息：
      ```bash
      git fetch --all --prune
      ```
   
   b. 为短名称查找所有来源中的最高功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 规范目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录
   
   c. 确定下一个可用编号：
      - 从所有三个来源提取所有编号
      - 找到最高编号 N
      - 为新分支编号使用 N+1
   
   d. 使用计算的编号和短名称运行脚本 `{SCRIPT}`：
      - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
      - Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`
   
   **重要**：
   - 检查所有三个来源（远程分支、本地分支、规范目录）以找到最高编号
   - 仅匹配具有确切短名称模式的分支/目录
   - 如果未找到此短名称的现有分支/目录，从编号 1 开始
   - 每个功能只能运行此脚本一次
   - JSON 在终端中作为输出提供 - 始终参考它来获取您要查找的实际内容
   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于参数中的单引号如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或者可能的话使用双引号："I'm Groot"）

3. 加载 `templates/spec-template.md` 以了解所需部分。

4. 遵循此执行流程：

    1. 从输入解析用户描述
       如果为空：错误 "未提供功能描述"
    2. 从描述中提取关键概念
       识别：参与者、动作、数据、约束
    3. 对于不清楚的方面：
       - 基于上下文和行业标准做出明智猜测
       - 仅在以下情况下标记 [需要澄清：具体问题]：
         - 该选择显著影响功能范围或用户体验
         - 存在多个合理的解释且有不同的含义
         - 不存在合理的默认值
       - **LIMIT: Maximum 3 [NEEDS CLARIFICATION] markers total**
       - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details
    4. Fill User Scenarios & Testing section
       If no clear user flow: ERROR "Cannot determine user scenarios"
    5. Generate Functional Requirements
       Each requirement must be testable
       Use reasonable defaults for unspecified details (document assumptions in Assumptions section)
    6. Define Success Criteria
       Create measurable, technology-agnostic outcomes
       Include both quantitative metrics (time, performance, volume) and qualitative measures (user satisfaction, task completion)
       Each criterion must be verifiable without implementation details
    7. 识别关键实体（如涉及数据）
    8. 返回：成功（规范已准备好进行规划）

5. 使用模板结构将规范写入 SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保持部分顺序和标题。

6. **规范质量验证**：编写初始规范后，根据质量标准验证：

   a. **创建规范质量检查清单**：使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件，包含以下验证项：

      ```markdown
      # 规范质量检查清单：[功能名称]
      
      **目的**：在进入规划前验证规范完整性和质量
      **创建时间**：[日期]
      **功能**：[链接到 spec.md]
      
      ## 内容质量
      
      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有强制部分已完成
      
      ## 需求完整性
      
      - [ ] 不再有 [需要澄清] 标记
      - [ ] 需求可测试且明确
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（无实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 边界情况已识别
      - [ ] 范围边界清晰
      - [ ] 依赖关系和假设已识别
      
      ## 功能就绪度
      
      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 规范中没有泄露实现细节
      
      ## 备注
      
      - 标记为不完整的项目需要在执行 `/speckit.clarify` 或 `/speckit.plan` 前更新规范
      ```

   b. **运行验证检查**：根据每个检查清单项目审查规范：
      - 对于每个项目，确定是否通过或失败
      - 记录发现的具体问题（引用相关规范部分）

   c. **处理验证结果**：

      - **如果所有项目通过**：标记检查清单完成并继续步骤 6

      - **如果项目失败（排除 [需要澄清]）**：
        1. 列出失败项目和具体问题
        2. 更新规范以解决每个问题
        3. 重新运行验证直到所有项目通过（最多 3 次迭代）
        4. 如果 3 次迭代后仍然失败，在检查清单备注中记录剩余问题并警告用户

      - **如果仍有 [需要澄清] 标记**：
        1. 从规范中提取所有 [需要澄清：...] 标记
        2. **限制检查**：如果存在超过 3 个标记，仅保留 3 个最关键的（按范围/安全性/用户体验影响），并对其余标记做出明智猜测
        3. 对于每个需要澄清的问题（最多 3 个），以此格式向用户呈现选项：

           ```markdown
           ## 问题 [N]：[主题]
           
           **上下文**：[引用相关规范部分]
           
           **我们需要了解的**：[来自需要澄清标记的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A    | [第一个建议答案] | [这对功能意味着什么] |
           | B    | [第二个建议答案] | [这对功能意味着什么] |
           | C    | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供您自己的答案 | [说明如何提供自定义输入] |
           
           **您的选择**：_[等待用户响应]_
           ```

        4. **关键 - 表格格式**：确保 markdown 表格格式正确：
           - 使用一致的间距，管道符对齐
           - 每个单元格内容周围应有空格：`| 内容 |` 而不是 `|内容|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 测试表格在 markdown 预览中正确渲染
        5. 按顺序编号问题（Q1、Q2、Q3 - 最多共 3 个）
        6. 等待响应前一起呈现所有问题
        7. 等待用户对所有问题做出选择响应（例如，"Q1: A, Q2: 自定义 - [详情], Q3: B"）
        8. 通过用用户选择或提供的答案替换每个 [需要澄清] 标记来更新规范
        9. 所有澄清解决后重新运行验证

   d. **更新检查清单**：每次验证迭代后，更新检查清单文件的当前通过/失败状态

7. 报告完成情况，包括分支名称、规范文件路径、检查清单结果以及下一阶段的就绪状态（`/speckit.clarify` 或 `/speckit.plan`）。

**注意**：脚本在写入前创建并切换到新分支并初始化规范文件。

## 通用指南

## 快速指南

- 专注于用户**需要什么**和**为什么**。
- 避免如何实现（无技术栈、API、代码结构）。
- 为业务利益相关者而非开发者编写。
- 不要创建嵌入在规范中的任何检查清单。那将是一个单独的命令。

### 部分要求

- **强制部分**：每个功能都必须完成
- **可选部分**：仅在与功能相关时包含
- 当部分不适用时，完全删除它（不要留作"N/A"）

### AI 生成指南

从用户提示创建此规范时：

1. **做出明智的猜测**：利用上下文、行业标准和通用模式来填补空白
2. **记录假设**：在"假设"部分记录合理的默认值
3. **限制澄清**：最多 3 个 [需要澄清] 标记 - 仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 存在多个合理的解释且有不同的含义
   - 缺乏任何合理的默认值
4. **优先级澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：每个模糊的需求都应该在"可测试和明确"检查清单项中失败
6. **需要澄清的常见领域**（仅当不存在合理的默认值时）：
   - 功能范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果有多个相互冲突的解释）
   - 安全/合规要求（在法律/财务上很重要时）

**合理默认值示例**（不要问这些）：

- 数据保留：域特定的行业标准实践
- 性能目标：标准 Web/移动应用程序期望（如未指定）
- 错误处理：用户友好的消息带适当的回退
- 身份验证方法：标准基于会话或 OAuth2 网络应用程序
- 集成模式：除非指定，否则为 RESTful API

### 成功标准指南

成功标准必须：

1. **可衡量**：包含具体指标（时间、百分比、计数、速率）
2. **技术无关**：不提及框架、语言、数据库或工具
3. **以用户为中心**：从用户/业务角度描述结果，而不是系统内部结构
4. **可验证**：无需了解实现细节即可进行测试/验证

**好示例**：

- "用户可以在 3 分钟内完成结账"
- "系统支持 10,000 个并发用户"
- "95% 的搜索在 1 秒内返回结果"
- "任务完成率提高了 40%"

**坏示例**（以实现为中心）：

- "API 响应时间在 200 毫秒以下"（太技术性，改为"用户立即看到结果"）
- "数据库可以处理 1000 TPS"（实现细节，使用面向用户的指标）
- "React 组件高效渲染"（特定框架）
- "Redis 缓存命中率高于 80%"（技术特定）
