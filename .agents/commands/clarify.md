---
description: 通过提出最多 5 个高度针对性的澄清问题，识别当前功能规范中规范不足的领域，并将答案编码回规范中。
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 用户输入

```text
$ARGUMENTS
```

您**必须**在继续前考虑用户输入（如果不为空）。

## 概述

目标：检测并减少活动功能规范中的歧义或缺失的决策点，并将澄清直接记录在规范文件中。

注意：此澄清工作流程应在调用 `/speckit.plan` 前运行（并完成）。如果用户明确声称跳过澄清（例如，探索性 spike），您可以继续，但必须警告下游返工风险增加。

执行步骤：

1. 从存储库根目录运行 `{SCRIPT}` **一次**（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最少 JSON 有效负载字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 以供未来链式流程使用。）
   - 如果 JSON 解析失败，中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。
   - 对于 args 中的单引号，如"I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或如果可能，使用双引号："I'm Groot"）。

2. 加载当前规范文件。使用此分类法执行结构化歧义和覆盖范围扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖范围图（除非将没有要提出的问题，否则不输出原始映射）。

   功能范围和行为：
   - 核心用户目标和成功标准
   - 明确的超出范围声明
   - 用户角色 / 角色区分

   域和数据模型：
   - 实体、属性、关系
   - 身份和唯一性规则
   - 生命周期/状态转换
   - 数据量/规模假设

   - 关键用户旅程/序列
   - 错误/空/加载状态
   - 可访问性或本地化说明

   ---
   - 可衡量的完成定义风格指标

   杂项 / 占位符：
   - TODO 标记 / 未解决的决策

   对于状态为"部分"或"缺失"的每个类别，添加候选问题机会，除非：
   - 澄清不会从物质上改变实现或验证策略
   - 信息更好地推迟到规划阶段（内部记录）

3. 生成（内部）候选澄清问题的优先级队列（最多 5 个）。**不要**一次性输出所有问题。应用以下限制：
    - 整个会话中最多 10 个问题。
    - 每个问题必须可以通过以下任一方式回答：
       - 短多项选择（2-5 个不同的、相互排斥的选项），或
       - 一个词 / 短语答案（明确限制："用不超过 5 个词回答"）。
    - 倾向于减少下游返工风险或防止错误的接受测试的澄清。
    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。

4. 顺序提问循环（交互式）：
    - **一次呈现恰好一个问题**。
    - 对于多项选择问题：
       - **分析所有选项**并根据以下条件确定**最合适的选项**：
          - 项目类型的最佳实践
          - 类似实现中的通用模式
          - 风险降低（安全性、性能、可维护性）

       | 选项 | 描述 |
       |--------|-------------|
       | A | <选项 A 描述> |
       | B | <选项 B 描述> |
       | C | <选项 C 描述>（根据需要添加 D/E，最多 5 个） |
       | 简短 | 提供不同的简短答案（<=5 个词）（仅在自由形式替代方案适当时包含） |

       - 在表格后添加：`您可以使用选项字母回复（例如，"A"），通过说"yes"或"recommended"接受建议，或提供您自己的简短答案。`
    - 对于简短答案风格（没有有意义的离散选项）：
       - 根据最佳实践和上下文提供您的**建议答案**。
       - 格式为：`**建议：** <您的建议答案> - <简要推理>`
       - 然后输出：`格式：简短答案（<=5 个词）。您可以通过说"yes"或"suggested"接受建议，或提供您自己的答案。`
    - 用户回答后：
       - 如果用户使用"yes"、"recommended"或"suggested"回复，使用您之前陈述的建议/建议作为答案。
       - 否则，验证答案映射到一个选项或符合 <=5 字限制。
       - 如果不明确，要求快速消除歧义（计数仍然属于同一问题；不推进）。
       - 满足后，将其记录在工作内存中（尚不写入磁盘）并移至下一个队列的问题。
    - 在以下情况下停止提问：
       - 所有关键歧义都尽早解决（剩余排队项目变得不必要），或
       - 用户发出完成信号（"done"、"good"、"no more"），或
       - 您提出了 5 个问题。
    - 不要提前透露未来排队的问题。
    - 如果开始时不存在有效问题，立即报告没有关键歧义。

5. 每次接受答案后集成（增量更新方法）：
    - 维护规范的内存表示（在开始时加载一次）加上原始文件内容。
    - 对于此会话中的第一个集成答案：
       - 确保存在 `## 澄清` 部分（如果缺失，请在规范模板中最高级别的上下文/概述部分之后创建）。
       - 在其下，为今天创建（如果不存在）`### 会话 YYYY-MM-DD` 子标题。
    - 接受后立即附加一条项目符号：`- Q：<问题> → A：<最终答案>`。
    - 然后立即将澄清应用到最合适的部分：
       - 功能歧义 → 更新或在"功能需求"中添加项目符号。
       - 用户交互 / 角色区分 → 用澄清的角色、约束或场景更新"用户故事"或"参与者"子部分（如果存在）。
       - 数据形状 / 实体 → 更新"数据模型"（添加字段、类型、关系）保留排序；简洁地记录添加的约束。
       - 非功能约束 → 在"非功能 / 质量属性"部分添加/修改可衡量的标准（将模糊形容词转换为指标或明确目标）。
       - 边界情况 / 否定流程 → 在"边界情况 / 错误处理"下添加新项目符号（或如果模板提供占位符，创建此类子部分）。
       - 术语冲突 → 在规范中规范术语；仅当必要时保留原始文本，添加 `（以前称为"X"）` 一次。
    - 如果澄清使早期的模糊陈述失效，请替换该陈述而不是重复；不留下过时的矛盾文本。
    - 在每次集成后保存规范文件以最小化上下文丧失的风险（原子覆盖）。
    - 保留格式：不要重新排列无关的部分；保持标题层次结构完整。
    - 保持每个插入的澄清最小且可测试（避免叙事漂移）。

6. 验证（在每次写入后以及最终传递后执行）：
   - 澄清会话在每个已接受的答案中恰好包含一条项目符号（无重复）。
   - 提出的问题总数（已接受）≤ 5。
   - 更新的部分不包含新答案应该解决的挥之不去的模糊占位符。
   - 没有矛盾的早期陈述仍然存在（扫描现在无效的替代选择已删除）。
   - Markdown 结构有效；仅允许新标题：`## 澄清`、`### 会话 YYYY-MM-DD`。
   - 术语一致性：在所有更新的部分中使用相同的规范术语。

7. 将更新的规范写回到 `FEATURE_SPEC`。

8. 报告完成（提问循环结束或提前终止后）：
   - 提问和回答的问题数量。
   - 更新规范的路径。
   - 涉及的部分（列出名称）。
   - 覆盖范围摘要表，列出每个分类法类别，状态为：已解决（曾是部分/缺失并已处理）、延迟（超过问题配额或更适合规划）、清晰（已充分）、未解决（仍为部分/缺失但低影响）。
   - 如果任何未解决或延迟仍然存在，建议是继续进行 `/speckit.plan` 还是稍后规划后重新运行 `/speckit.clarify`。
   - 建议的下一个命令。

行为规则：

- 如果没有发现有意义的歧义（或所有潜在问题都是低影响的），响应："未检测到值得正式澄清的关键歧义。"并建议继续进行。
- 如果规范文件丢失，指示用户首先运行 `/speckit.specify`（不要在此处创建新规范）。
- 永远不要超过 5 个已提出的问题总数（对单个问题的澄清重试不计为新问题）。
- 避免推测技术栈问题，除非缺失阻止功能清晰。
- 尊重用户的早期终止信号（"stop"、"done"、"proceed"）。
- 如果由于覆盖完全而未提出问题，输出紧凑覆盖范围摘要（所有类别清晰），然后建议前进。
- 如果达到配额且未解决的高影响类别仍然存在，在"延迟"下明确标记它们并说明原因。

优先级上下文：{ARGS}
