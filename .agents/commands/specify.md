---
description: 根据自然语言描述生成 feature 规范。
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

请务必在分析前充分考虑用户输入（如有）。

## 执行步骤

用户在触发消息中于 `/speckit.specify` 后输入的文本**即为**功能描述。假设在此对话中始终可用，即使下方字面显示 `{ARGS}`。除非用户提供空命令，否则不要要求用户重复。

根据该功能描述，执行以下操作：

1. **为分支生成简洁的短名称**（2-4 个词）：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个 2-4 个词的短名称，能够捕捉功能的本质
   - 尽可能使用动作-名词格式（例如，"add-user-auth"、"fix-payment-bug"）
   - 保留技术术语和缩写（OAuth2、API、JWT 等）
   - 保持简洁但足够描述以一目了然地理解功能
   - 示例：
     - "我想添加用户认证" → "user-auth"
     - "为 API 实现 OAuth2 集成" → "oauth2-api-integration"
     - "创建分析仪表板" → "analytics-dashboard"
     - "修复支付处理超时错误" → "fix-payment-timeout"

2. **在创建新分支前检查现有分支**：
   
   a. 首先，获取所有远程分支以确保我们有最新信息：
      ```bash
      git fetch --all --prune
      ```
   
   b. 为短名称查找所有来源中的最高功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 规范目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录
   
   c. 确定下一个可用编号：
      - 从所有三个来源提取所有编号
      - 找到最高编号 N
      - 为新分支编号使用 N+1
   
   d. 使用计算的编号和短名称运行脚本 `{SCRIPT}`：
      - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
      - Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`
   
   **重要**：
   - 检查所有三个来源（远程分支、本地分支、规范目录）以找到最高编号
   - 仅匹配具有确切短名称模式的分支/目录
   - 如果未找到此短名称的现有分支/目录，从编号 1 开始
   - 每个功能只能运行此脚本一次
   - JSON 在终端中作为输出提供 - 始终参考它来获取您要查找的实际内容
   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于参数中的单引号如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或者可能的话使用双引号："I'm Groot"）

3. 加载 `templates/spec-template.md` 以了解所需部分。

4. 遵循此执行流程：

    1. 从输入解析用户描述
       如果为空：错误 "未提供功能描述"
    2. 从描述中提取关键概念
       识别：参与者、动作、数据、约束
    3. 对于不清楚的方面：
       - 基于上下文和行业标准做出明智猜测
       - 仅在以下情况下标记 [需要澄清：具体问题]：
         - 该选择显著影响功能范围或用户体验
         - 存在多个合理的解释且有不同的含义
         - 不存在合理的默认值
       - **限制：最多 3 个 [需要澄清] 标记**
       - 按影响优先级排序澄清：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填充用户场景与测试部分
       如果没有清晰的用户流：错误 "无法确定用户场景"
    5. 生成功能需求
       每个需求都必须可测试
       对于未指定的细节使用合理的默认值（在假设部分记录）
    6. 定义成功标准
       创建可衡量的、与技术无关的结果
       包括定量指标（时间、性能、量）和定性测量（用户满意度、任务完成）
       每个标准都必须无需实现细节即可验证
    7. 识别关键实体（如涉及数据）
    8. 返回：成功（规范已准备好进行规划）

5. 使用模板结构将规范写入 SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保持部分顺序和标题。

6. **规范质量验证**：编写初始规范后，根据质量标准验证：

   a. **创建规范质量检查清单**：使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件，包含以下验证项：

      ```markdown
      # 规范质量检查清单：[功能名称]
      
      **目的**：在进入规划前验证规范完整性和质量
      **创建时间**：[日期]
      **功能**：[链接到 spec.md]
      
      ## 内容质量
      
      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有强制部分已完成
      
      ## 需求完整性
      
      - [ ] 不再有 [需要澄清] 标记
      - [ ] 需求可测试且明确
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（无实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 边界情况已识别
      - [ ] 范围边界清晰
      - [ ] 依赖关系和假设已识别
      
      ## 功能就绪度
      
      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 规范中没有泄露实现细节
      
      ## 备注
      
      - 标记为不完整的项目需要在执行 `/speckit.clarify` 或 `/speckit.plan` 前更新规范
      ```

   b. **运行验证检查**：根据每个检查清单项目审查规范：
      - 对于每个项目，确定是否通过或失败
      - 记录发现的具体问题（引用相关规范部分）

   c. **处理验证结果**：

      - **如果所有项目通过**：标记检查清单完成并继续步骤 7

      - **如果项目失败（排除 [需要澄清]）**：
        1. 列出失败项目和具体问题
        2. 更新规范以解决每个问题
        3. 重新运行验证直到所有项目通过（最多 3 次迭代）
        4. 如果 3 次迭代后仍然失败，在检查清单备注中记录剩余问题并警告用户

      - **如果仍有 [需要澄清] 标记**：
        1. 从规范中提取所有 [需要澄清：...] 标记
        2. **限制检查**：如果存在超过 3 个标记，仅保留 3 个最关键的（按范围/安全性/用户体验影响），并对其余标记做出明智猜测
        3. 对于每个需要澄清的问题（最多 3 个），以此格式向用户呈现选项：

           ```markdown
           ## 问题 [N]：[主题]
           
           **上下文**：[引用相关规范部分]
           
           **我们需要了解的**：[来自需要澄清标记的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A    | [第一个建议答案] | [这对功能意味着什么] |
           | B    | [第二个建议答案] | [这对功能意味着什么] |
           | C    | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供您自己的答案 | [说明如何提供自定义输入] |
           
           **您的选择**：_[等待用户响应]_
           ```

        4. **关键 - 表格格式**：确保 markdown 表格格式正确：
           - 使用一致的间距，管道符对齐
           - 每个单元格内容周围应有空格：`| 内容 |` 而不是 `|内容|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 测试表格在 markdown 预览中正确渲染
        5. 按顺序编号问题（Q1、Q2、Q3 - 最多共 3 个）
        6. 等待响应前一起呈现所有问题
        7. 等待用户对所有问题做出选择响应（例如，"Q1: A, Q2: 自定义 - [详情], Q3: B"）
        8. 通过用用户选择或提供的答案替换每个 [需要澄清] 标记来更新规范
        9. 所有澄清解决后重新运行验证

   d. **更新检查清单**：每次验证迭代后，更新检查清单文件的当前通过/失败状态

7. 报告完成情况，包括分支名称、规范文件路径、检查清单结果以及下一阶段的就绪状态（`/speckit.clarify` 或 `/speckit.plan`）。
